diff --git a/automl/google/cloud/automl_v1beta1/tables/tables_client.py b/automl/google/cloud/automl_v1beta1/tables/tables_client.py
index 576fa05eadb..b1ac30b79cb 100644
--- a/automl/google/cloud/automl_v1beta1/tables/tables_client.py
+++ b/automl/google/cloud/automl_v1beta1/tables/tables_client.py
@@ -1,12 +1,10 @@
-# -*- coding: utf-8 -*-
-#
-# Copyright 2019 Google LLC
+# Copyright 2019 Google Inc. All Rights Reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
-#     https://www.apache.org/licenses/LICENSE-2.0
+#     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
@@ -19,7 +17,6 @@
 import pkg_resources
 
 from google.api_core.gapic_v1 import client_info
-from google.api_core import exceptions
 from google.cloud import automl_v1beta1
 from google.cloud.automl_v1beta1.proto import data_types_pb2
 
@@ -33,8 +30,7 @@ class TablesClient(object):
     in particular for the `AutoML Tables product
     <https://cloud.google.com/automl-tables/>`_.
     """
-    def __init__(self, project=None, region='us-central1', client=None,
-            prediction_client=None, **kwargs):
+    def __init__(self, project=None, region='us-central1', **kwargs):
         """Constructor.
 
         Example:
@@ -93,20 +89,12 @@ class TablesClient(object):
             client_info_.user_agent = user_agent
             client_info_.gapic_version = version
 
-        if client is None:
-            self.client = automl_v1beta1.AutoMlClient(client_info=client_info_,
-                    **kwargs)
-        else:
-            self.client = client
-
-        if prediction_client is None:
-            self.prediction_client = automl_v1beta1.PredictionServiceClient(
-                    client_info=client_info_,
-                    **kwargs
-            )
-        else:
-            self.prediction_client = prediction_client
-
+        self.client = automl_v1beta1.AutoMlClient(client_info=client_info_, 
+                **kwargs)
+        self.prediction_client = automl_v1beta1.PredictionServiceClient(
+                client_info=client_info_, 
+                **kwargs
+        )
         self.project = project
         self.region = region
 
@@ -127,36 +115,6 @@ class TablesClient(object):
 
         return self.client.location_path(project, region)
 
-    # the returned metadata object doesn't allow for updating fields, so
-    # we need to manually copy user-updated fields over
-    def __update_metadata(self, metadata, k, v):
-        new_metadata = {}
-        new_metadata['ml_use_column_spec_id'] = metadata.ml_use_column_spec_id
-        new_metadata['weight_column_spec_id'] = metadata.weight_column_spec_id
-        new_metadata['target_column_spec_id'] = metadata.target_column_spec_id
-        new_metadata[k] = v
-
-        return new_metadata
-
-    def __dataset_from_args(self, dataset=None, dataset_display_name=None,
-            dataset_name=None, project=None, region=None):
-        if (dataset is None
-                and dataset_display_name is None
-                and dataset_name is None):
-            raise ValueError('One of \'dataset\', \'dataset_name\' or '
-                    '\'dataset_display_name\' must be set.')
-        # we prefer to make a live call here in the case that the
-        # dataset object is out-of-date
-        if dataset is not None:
-            dataset_name = dataset.name
-
-        return self.get_dataset(
-                dataset_display_name=dataset_display_name,
-                dataset_name=dataset_name,
-                project=project,
-                region=region
-        )
-
     def __dataset_name_from_args(self, dataset=None, dataset_display_name=None,
             dataset_name=None, project=None, region=None):
         if (dataset is None
@@ -172,17 +130,24 @@ class TablesClient(object):
                         project=project,
                         region=region
                 )
-
             dataset_name = dataset.name
-        else:
-            # we do this to force a NotFound error when needed
-            self.get_dataset(
-                    dataset_name=dataset_name,
-                    project=project,
-                    region=region
-            )
         return dataset_name
 
+    def __table_spec_full_name_from_args(self, table_spec_index=0, 
+            dataset=None, dataset_display_name=None,
+            dataset_name=None, project=None, region=None):
+
+        dataset_name = self.__dataset_name_from_args(dataset=dataset,
+                dataset_name=dataset_name,
+                dataset_display_name=dataset_display_name,
+                project=project,
+                region=region
+        )
+        table_specs = [t for t in self.list_table_specs(dataset_name=dataset_name)]
+        table_spec_full_id = table_specs[table_spec_index]
+        table_spec_full_id = table_specs[table_spec_index].name
+        return table_spec_full_id
+
     def __model_name_from_args(self, model=None, model_display_name=None,
             model_name=None, project=None, region=None):
         if (model is None
@@ -194,64 +159,39 @@ class TablesClient(object):
         if model_name is None:
             if model is None:
                 model = self.get_model(
-                        model_display_name=model_display_name,
+                        model_display_name=dataset_display_name,
                         project=project,
                         region=region
                 )
             model_name = model.name
-        else:
-            # we do this to force a NotFound error when needed
-            self.get_model(
-                    model_name=model_name,
-                    project=project,
-                    region=region
-            )
         return model_name
 
     def __column_spec_name_from_args(self, dataset=None, dataset_display_name=None,
             dataset_name=None, table_spec_name=None, table_spec_index=0,
             column_spec_name=None, column_spec_display_name=None,
             project=None, region=None):
-        column_specs = self.list_column_specs(dataset=dataset,
-                dataset_display_name=dataset_display_name,
-                dataset_name=dataset_name,
-                table_spec_name=table_spec_name,
-                table_spec_index=table_spec_index,
-                project=project,
-                region=region)
-        if column_spec_display_name is not None:
-            column_specs = {s.display_name: s for s in column_specs}
-            if column_specs.get(column_spec_display_name) is None:
-                raise exceptions.NotFound('No column with ' +
-                        'column_spec_display_name: \'{}\' found'.format(
-                            column_spec_display_name
-                        ))
+        if column_spec_name is None:
+            if column_spec_display_name is None:
+                raise ValueError('Either supply \'column_spec_name\' or '
+                        '\'column_spec_display_name\' for the column to update')
+            column_specs = {s.display_name: s for s in
+                    self.list_column_specs(dataset=dataset,
+                        dataset_display_name=dataset_display_name,
+                        dataset_name=dataset_name,
+                        table_spec_name=table_spec_name,
+                        table_spec_index=table_spec_index,
+                        project=project,
+                        region=region)
+            }
             column_spec_name = column_specs[column_spec_display_name].name
-        elif column_spec_name is not None:
-            column_specs = {s.name: s for s in column_specs}
-            if column_specs.get(column_spec_name) is None:
-                raise exceptions.NotFound('No column with ' +
-                        'column_spec_name: \'{}\' found'.format(
-                            column_spec_name
-                        ))
-        else:
-            raise ValueError('Either supply \'column_spec_name\' or '
-                    '\'column_spec_display_name\' for the column to update')
-
         return column_spec_name
 
+    ## TODO(lwander): what other type codes are there?
+    ## https://github.com/googleapis/google-cloud-python/blob/master/automl/google/cloud/automl_v1beta1/proto/data_types_pb2.py#L87-L92
     def __type_code_to_value_type(self, type_code):
         if type_code == data_types_pb2.FLOAT64:
             return 'number_value'
-        elif type_code == data_types_pb2.TIMESTAMP:
-            return 'string_value'
-        elif type_code == data_types_pb2.STRING:
-            return 'string_value'
-        elif type_code == data_types_pb2.ARRAY:
-            return 'list_value'
-        elif type_code == data_types_pb2.STRUCT:
-            return 'struct_value'
-        elif type_code == data_types_pb2.CATEGORY:
+        if type_code == data_types_pb2.CATEGORY:
             return 'string_value'
         else:
             raise ValueError('Unknown type_code: {}'.format(type_code))
@@ -339,8 +279,7 @@ class TablesClient(object):
                 must be provided.
 
         Returns:
-            A :class:`~google.cloud.automl_v1beta1.types.Dataset` instance if
-            found, `None` otherwise.
+            A :class:`~google.cloud.automl_v1beta1.types.Dataset` instance.
 
         Raises:
             google.api_core.exceptions.GoogleAPICallError: If the request
@@ -356,15 +295,10 @@ class TablesClient(object):
         if dataset_name is not None:
             return self.client.get_dataset(dataset_name)
 
-        result = next((d for d in self.list_datasets(project, region)
-                if d.display_name == dataset_display_name), None)
-
-        if result is None:
-            raise exceptions.NotFound(('Dataset with display_name: \'{}\' ' +
-                'not found').format(dataset_display_name))
-
-        return result
+        return next(d for d in self.list_datasets(project, region)
+                if d.display_name == dataset_display_name)
 
+    ## TODO(lwander): is metadata needed here?
     def create_dataset(self, dataset_display_name, metadata={}, project=None,
             region=None):
         """Create a dataset. Keep in mind, importing data is a separate step.
@@ -463,18 +397,15 @@ class TablesClient(object):
                 to a retryable error and retry attempts failed.
             ValueError: If required parameters are missing.
         """
-        try:
-            dataset_name = self.__dataset_name_from_args(dataset=dataset,
-                    dataset_name=dataset_name,
-                    dataset_display_name=dataset_display_name,
-                    project=project,
-                    region=region)
-        # delete is idempotent
-        except exceptions.NotFound:
-            return None
+        dataset_name = self.__dataset_name_from_args(dataset=dataset,
+                dataset_name=dataset_name,
+                dataset_display_name=dataset_display_name,
+                project=project,
+                region=region)
 
         return self.client.delete_dataset(dataset_name)
 
+    ## TODO(lwander): why multiple input GCS files? why not bq?
     def import_data(self, dataset=None, dataset_display_name=None,
             dataset_name=None, gcs_input_uris=None,
             bigquery_input_uri=None, project=None, region=None):
@@ -799,8 +730,6 @@ class TablesClient(object):
 
         # type code must always be set
         if type_code is None:
-            # this index is safe, we would have already thrown a NotFound
-            # had the column_spec_name not existed
             type_code = {s.name: s for s in self.list_column_specs(
                     dataset=dataset,
                     dataset_display_name=dataset_display_name,
@@ -914,23 +843,122 @@ class TablesClient(object):
         )
         column_spec_id = column_spec_name.rsplit('/', 1)[-1]
 
-        dataset = self.__dataset_from_args(dataset=dataset,
+        dataset_name = self.__dataset_name_from_args(dataset=dataset,
                 dataset_name=dataset_name,
                 dataset_display_name=dataset_display_name,
                 project=project,
                 region=region)
-        metadata = dataset.tables_dataset_metadata
-        metadata = self.__update_metadata(metadata,
-                'target_column_spec_id',
-                column_spec_id)
 
         request = {
-                'name': dataset.name,
-                'tables_dataset_metadata': metadata,
+                'name': dataset_name,
+                'tables_dataset_metadata': {
+                    'target_column_spec_id': column_spec_id
+                }
         }
 
         return self.client.update_dataset(request)
 
+    def set_time_column(self, dataset=None, dataset_display_name=None,
+            dataset_name=None, table_spec_name=None, table_spec_index=0,
+            column_spec_name=None, column_spec_display_name=None, 
+            project=None, region=None):
+        """Sets the time column which designates which data
+        will be of type timestamp and will be used for the timeseries data.
+        . This column must be of type timestamp.
+        Example:
+            >>> from google.cloud import automl_v1beta1
+            >>>
+            >>> client = automl_v1beta1.tables.ClientHelper(
+            ...     client=automl_v1beta1.AutoMlClient(),
+            ...     project='my-project', region='us-central1')
+            ...
+            >>> client.set_time_column(dataset_display_name='my_dataset',
+            ...     column_spec__name='Unix Time')
+            ...
+        Args:
+            project (Optional[string]):
+                If you have initialized the client with a value for `project`
+                it will be used if this parameter is not supplied. Keep in
+                mind, the service account this client was initialized with must
+                have access to this project.
+            region (Optional[string]):
+                If you have initialized the client with a value for `region` it
+                will be used if this parameter is not supplied.
+            column_spec_name (Optional[string]):
+                The name AutoML-assigned name for the column you want to set as
+                the time column.
+            column_spec_display_name (Optional[string]):
+                The human-readable name of the column you want to set as the
+                time column. If this is supplied in place of
+                `column_spec_name`, you also need to provide either a way to
+                lookup the source dataset (using one of the `dataset*` kwargs),
+                or the `table_spec_name` of the table this column belongs to.
+            table_spec_name (Optional[string]):
+                The AutoML-assigned name for the table whose time column
+                you want to set . If not supplied, the client can determine
+                this name from a source `Dataset` object.
+            table_spec_index (Optional[int]):
+                If no `table_spec_name` or `column_spec_name` was provided, we
+                use this index to determine which table to set the time
+                column on.
+            dataset_display_name (Optional[string]):
+                The human-readable name given to the dataset you want to update
+                the time column of. If no `table_spec_name` is supplied,
+                this will be used together with `table_spec_index` to infer the
+                name of table to update the time column of. This must be
+                supplied if `table_spec_name`, `dataset` or `dataset_name` are
+                not supplied.
+            dataset_name (Optional[string]):
+                The AutoML-assigned name given to the dataset you want to
+                update the time column of. If no `table_spec_name` is
+                supplied, this will be used together with `table_spec_index` to
+                infer the name of table to update the time column of.
+                This must be supplied if `table_spec_name`, `dataset` or
+                `dataset_display_name` are not supplied.
+            dataset (Optional[Dataset]):
+                The `Dataset` instance you want to update the time column
+                of.  If no `table_spec_name` is supplied, this will be used
+                together with `table_spec_index` to infer the name of table to
+                update the time column of. This must be supplied if
+                `table_spec_name`, `dataset_name` or `dataset_display_name` are
+                not supplied.
+        Returns:
+            A :class:`~google.cloud.automl_v1beta1.types.Dataset` instance.
+        Raises:
+            google.api_core.exceptions.GoogleAPICallError: If the request
+                failed for any reason.
+            google.api_core.exceptions.RetryError: If the request failed due
+                to a retryable error and retry attempts failed.
+            ValueError: If required parameters are missing.
+        """
+        column_spec_name = self.__column_spec_name_from_args(
+                dataset=dataset,
+                dataset_display_name=dataset_display_name,
+                dataset_name=dataset_name,
+                table_spec_name=table_spec_name,
+                table_spec_index=table_spec_index,
+                column_spec_name=column_spec_name,
+                column_spec_display_name=column_spec_display_name,
+                project=project,
+                region=region
+        )
+        column_spec_id = column_spec_name.rsplit('/', 1)[-1]
+
+        dataset_name = self.__dataset_name_from_args(dataset=dataset,
+                dataset_name=dataset_name,
+                dataset_display_name=dataset_display_name,
+                project=project,
+                region=region)
+        
+        table_spec_full_id = self.__table_spec_full_name_from_args(dataset_name=dataset_name)
+        
+        my_table_spec = {
+        'name': table_spec_full_id,
+        'time_column_spec_id': column_spec_id
+        }
+
+        response = self.client.update_table_spec(my_table_spec)  
+
     def set_weight_column(self, dataset=None, dataset_display_name=None,
             dataset_name=None, table_spec_name=None, table_spec_index=0,
             column_spec_name=None, column_spec_display_name=None,
@@ -1021,19 +1049,17 @@ class TablesClient(object):
         )
         column_spec_id = column_spec_name.rsplit('/', 1)[-1]
 
-        dataset = self.__dataset_from_args(dataset=dataset,
+        dataset_name = self.__dataset_name_from_args(dataset=dataset,
                 dataset_name=dataset_name,
                 dataset_display_name=dataset_display_name,
                 project=project,
                 region=region)
-        metadata = dataset.tables_dataset_metadata
-        metadata = self.__update_metadata(metadata,
-                'weight_column_spec_id',
-                column_spec_id)
 
         request = {
-                'name': dataset.name,
-                'tables_dataset_metadata': metadata,
+                'name': dataset_name,
+                'tables_dataset_metadata': {
+                    'weight_column_spec_id': column_spec_id
+                }
         }
 
         return self.client.update_dataset(request)
@@ -1129,17 +1155,17 @@ class TablesClient(object):
         )
         column_spec_id = column_spec_name.rsplit('/', 1)[-1]
 
-        dataset = self.__dataset_from_args(dataset=dataset,
+        dataset_name = self.__dataset_name_from_args(dataset=dataset,
                 dataset_name=dataset_name,
                 dataset_display_name=dataset_display_name,
                 project=project,
                 region=region)
-        metadata = dataset.tables_dataset_metadata
-        metadata = self.__update_metadata(metadata, 'ml_use_column_spec_id', column_spec_id)
 
         request = {
-                'name': dataset.name,
-                'tables_dataset_metadata': metadata,
+                'name': dataset_name,
+                'tables_dataset_metadata': {
+                    'ml_use_column_spec_id': column_spec_id
+                }
         }
 
         return self.client.update_dataset(request)
@@ -1193,9 +1219,7 @@ class TablesClient(object):
     def create_model(self, model_display_name, dataset=None,
             dataset_display_name=None, dataset_name=None,
             train_budget_milli_node_hours=None, project=None,
-            region=None, model_metadata={},
-            input_feature_column_specs_included=None,
-            input_feature_column_specs_excluded=None):
+            region=None, input_feature_column_specs_included=None, input_feature_column_specs_excluded=None):
         """Create a model. This will train your model on the given dataset.
 
         Example:
@@ -1239,8 +1263,6 @@ class TablesClient(object):
                 The `Dataset` instance you want to train your model on. This
                 must be supplied if `dataset_display_name` or `dataset_name`
                 are not supplied.
-            model_metadata (Optional[Dict]):
-                Optional model metadata to supply to the client.
             input_feature_column_specs_included(Optional[string]):
                 The list of the names of the columns you want to include to train
                 your model on.
@@ -1273,7 +1295,9 @@ class TablesClient(object):
             project=project,
             region=region)
 
-        model_metadata['train_budget_milli_node_hours'] = train_budget_milli_node_hours
+        tables_model_metadata = {
+            'train_budget_milli_node_hours': train_budget_milli_node_hours
+        }
 
         dataset_id = dataset_name.rsplit('/', 1)[-1]
         columns = [s for s in self.list_column_specs(dataset=dataset,
@@ -1286,18 +1310,18 @@ class TablesClient(object):
                 if c.display_name in input_feature_column_specs_included:
                     final_columns.append(c)
 
-            model_metadata['input_feature_column_specs'] = final_columns
+            tables_model_metadata['input_feature_column_specs'] = final_columns
         elif input_feature_column_specs_excluded:
             for a in columns:
                 if a.display_name not in input_feature_column_specs_excluded:
                     final_columns.append(a)
 
-            model_metadata['input_feature_column_specs'] = final_columns
+            tables_model_metadata['input_feature_column_specs'] = final_columns
 
         request = {
             'display_name': model_display_name,
             'dataset_id': dataset_id,
-            'tables_model_metadata': model_metadata
+            'tables_model_metadata': tables_model_metadata
         }
 
         return self.client.create_model(
@@ -1357,15 +1381,11 @@ class TablesClient(object):
                 to a retryable error and retry attempts failed.
             ValueError: If required parameters are missing.
         """
-        try:
-            model_name = self.__model_name_from_args(model=model,
-                    model_name=model_name,
-                    model_display_name=model_display_name,
-                    project=project,
-                    region=region)
-        # delete is idempotent
-        except exceptions.NotFound:
-            return None
+        model_name = self.__model_name_from_args(model=model,
+                model_name=model_name,
+                model_display_name=model_display_name,
+                project=project,
+                region=region)
 
         return self.client.delete_model(model_name)
 
@@ -1419,17 +1439,9 @@ class TablesClient(object):
             raise ValueError('One of \'model_name\' or '
                     '\'model_display_name\' must be set.')
 
-        if model_name is not None:
-            return self.client.get_model(model_name)
-
-        model = next((d for d in self.list_models(project, region)
-                if d.display_name == model_display_name), None)
-        
-        if model is None:
-            raise exceptions.NotFound('No model with model_diplay_name: ' +
-                    '\'{}\' found'.format(model_display_name))
-
-        return model
+        return next(m for m in self.list_models(project, region)
+                if m.name == model_name
+                or m.display_name == model_display_name)
 
     #TODO(jonathanskim): allow deployment from just model ID
     def deploy_model(self, model=None, model_name=None,
diff --git a/automl/tests/unit/gapic/v1beta1/test_tables_client_v1beta1.py b/automl/tests/unit/gapic/v1beta1/test_tables_client_v1beta1.py
deleted file mode 100644
index 6e4c66da255..00000000000
--- a/automl/tests/unit/gapic/v1beta1/test_tables_client_v1beta1.py
+++ /dev/null
@@ -1,672 +0,0 @@
-# -*- coding: utf-8 -*-
-#
-# Copyright 2019 Google LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     https://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""Unit tests."""
-
-import mock
-import pytest
-
-from google.cloud import automl_v1beta1
-from google.api_core import exceptions
-
-PROJECT='project'
-REGION='region'
-LOCATION_PATH='projects/{}/locations/{}'.format(PROJECT, REGION)
-
-class TestTablesClient(object):
-
-    def tables_client(self, client_attrs={},
-            prediction_client_attrs={}):
-        client_mock = mock.Mock(**client_attrs)
-        prediction_client_mock = mock.Mock(**prediction_client_attrs)
-        return automl_v1beta1.TablesClient(client=client_mock,
-                prediction_client=prediction_client_mock,
-                project=PROJECT, region=REGION)
-
-    def test_list_datasets_empty(self):
-        client = self.tables_client({
-            'list_datasets.return_value': [],
-            'location_path.return_value': LOCATION_PATH,
-        }, {})
-        ds = client.list_datasets()
-        client.client.location_path.assert_called_with(PROJECT, REGION)
-        client.client.list_datasets.assert_called_with(LOCATION_PATH)
-        assert ds == []
-
-    def test_list_datasets_not_empty(self):
-        datasets = ['some_dataset']
-        client = self.tables_client({
-            'list_datasets.return_value': datasets,
-            'location_path.return_value': LOCATION_PATH,
-        }, {})
-        ds = client.list_datasets()
-        client.client.location_path.assert_called_with(PROJECT, REGION)
-        client.client.list_datasets.assert_called_with(LOCATION_PATH)
-        assert len(ds) == 1
-        assert ds[0] == 'some_dataset'
-
-    def test_get_dataset_name(self):
-        dataset_actual = 'dataset'
-        client = self.tables_client({
-            'get_dataset.return_value': dataset_actual
-            }, {})
-        dataset = client.get_dataset(dataset_name='my_dataset')
-        client.client.get_dataset.assert_called_with('my_dataset')
-        assert dataset == dataset_actual
-
-    def test_get_no_dataset(self):
-        client = self.tables_client({
-            'get_dataset.side_effect': exceptions.NotFound('err')
-        }, {})
-        try:
-            client.get_dataset(dataset_name='my_dataset')
-        except exceptions.NotFound:
-            pass
-        client.client.get_dataset.assert_called_with('my_dataset')
-
-    def test_get_dataset_from_empty_list(self):
-        client = self.tables_client({'list_datasets.return_value': []}, {})
-        try:
-            client.get_dataset(dataset_display_name='my_dataset')
-        except exceptions.NotFound:
-            pass
-
-    def test_get_dataset_from_list_not_found(self):
-        client = self.tables_client({
-            'list_datasets.return_value': [mock.Mock(display_name='not_it')]
-        }, {})
-        try:
-            client.get_dataset(dataset_display_name='my_dataset')
-        except exceptions.NotFound:
-            pass
-
-    def test_get_dataset_from_list(self):
-        client = self.tables_client({
-            'list_datasets.return_value': [
-                mock.Mock(display_name='not_it'),
-                mock.Mock(display_name='my_dataset'),
-            ]
-        }, {})
-        dataset = client.get_dataset(dataset_display_name='my_dataset')
-        assert dataset.display_name == 'my_dataset'
-
-    def test_create_dataset(self):
-        client = self.tables_client({
-            'location_path.return_value': LOCATION_PATH,
-            'create_dataset.return_value': mock.Mock(display_name='name'),
-        }, {})
-        metadata = {'metadata': 'values'}
-        dataset = client.create_dataset('name', metadata=metadata)
-        client.client.location_path.assert_called_with(PROJECT, REGION)
-        client.client.create_dataset.assert_called_with(
-                LOCATION_PATH,
-                {'display_name': 'name', 'tables_dataset_metadata': metadata}
-        )
-        assert dataset.display_name == 'name'
-
-    def test_delete_dataset(self):
-        dataset = mock.Mock()
-        dataset.configure_mock(name='name')
-        client = self.tables_client({
-            'delete_dataset.return_value': None,
-        }, {})
-        client.delete_dataset(dataset=dataset)
-        client.client.delete_dataset.assert_called_with('name')
-
-    def test_delete_dataset_not_found(self):
-        client = self.tables_client({
-            'list_datasets.return_value': [],
-        }, {})
-        client.delete_dataset(dataset_display_name='not_found')
-        client.client.delete_dataset.assert_not_called()
-
-    def test_delete_dataset_name(self):
-        client = self.tables_client({
-            'delete_dataset.return_value': None,
-        }, {})
-        client.delete_dataset(dataset_name='name')
-        client.client.delete_dataset.assert_called_with('name')
-
-    def test_import_not_found(self):
-        client = self.tables_client({
-            'list_datasets.return_value': [],
-        }, {})
-        try:
-            client.import_data(dataset_display_name='name', gcs_input_uris='uri')
-        except exceptions.NotFound:
-            pass
-
-        client.client.import_data.assert_not_called()
-
-    def test_import_gcs_uri(self):
-        client = self.tables_client({
-            'import_data.return_value': None,
-        }, {})
-        client.import_data(dataset_name='name', gcs_input_uris='uri')
-        client.client.import_data.assert_called_with('name', {
-            'gcs_source': {'input_uris': ['uri']}
-        })
-
-    def test_import_gcs_uris(self):
-        client = self.tables_client({
-            'import_data.return_value': None,
-        }, {})
-        client.import_data(dataset_name='name',
-                gcs_input_uris=['uri', 'uri'])
-        client.client.import_data.assert_called_with('name', {
-            'gcs_source': {'input_uris': ['uri', 'uri']}
-        })
-
-    def test_import_bq_uri(self):
-        client = self.tables_client({
-            'import_data.return_value': None,
-        }, {})
-        client.import_data(dataset_name='name',
-                bigquery_input_uri='uri')
-        client.client.import_data.assert_called_with('name', {
-            'bigquery_source': {'input_uri': 'uri'}
-        })
-
-    def test_list_table_specs(self):
-        client = self.tables_client({
-            'list_table_specs.return_value': None,
-        }, {})
-        client.list_table_specs(dataset_name='name')
-        client.client.list_table_specs.assert_called_with('name')
-
-    def test_list_table_specs_not_found(self):
-        client = self.tables_client({
-            'list_table_specs.side_effect': exceptions.NotFound('not found'),
-        }, {})
-        try:
-            client.list_table_specs(dataset_name='name')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-
-    def test_list_column_specs(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [],
-        }, {})
-        client.list_column_specs(dataset_name='name')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-
-    def test_update_column_spec_not_found(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        try:
-            client.update_column_spec(dataset_name='name',
-                    column_spec_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_not_called()
-
-    def test_update_column_spec_display_name_not_found(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        try:
-            client.update_column_spec(dataset_name='name',
-                    column_spec_display_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_not_called()
-
-    def test_update_column_spec_name_no_args(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column/2', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.update_column_spec(dataset_name='name',
-                column_spec_name='column/2')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_called_with({
-            'name': 'column/2',
-            'data_type': {
-                'type_code': 'type_code',
-            }
-        })
-
-    def test_update_column_spec_no_args(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.update_column_spec(dataset_name='name',
-                column_spec_display_name='column')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_called_with({
-            'name': 'column',
-            'data_type': {
-                'type_code': 'type_code',
-            }
-        })
-
-    def test_update_column_spec_nullable(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.update_column_spec(dataset_name='name',
-                column_spec_display_name='column', nullable=True)
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_called_with({
-            'name': 'column',
-            'data_type': {
-                'type_code': 'type_code',
-                'nullable': True,
-            }
-        })
-
-    def test_update_column_spec_type_code(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.update_column_spec(dataset_name='name',
-                column_spec_display_name='column', type_code='type_code2')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_called_with({
-            'name': 'column',
-            'data_type': {
-                'type_code': 'type_code2',
-            }
-        })
-
-    def test_update_column_spec_type_code_nullable(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.update_column_spec(dataset_name='name', nullable=True,
-                column_spec_display_name='column', type_code='type_code2')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_called_with({
-            'name': 'column',
-            'data_type': {
-                'type_code': 'type_code2',
-                'nullable': True,
-            }
-        })
-
-    def test_update_column_spec_type_code_nullable_false(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        data_type_mock = mock.Mock(type_code='type_code')
-        column_spec_mock.configure_mock(name='column', display_name='column',
-                data_type=data_type_mock)
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.update_column_spec(dataset_name='name', nullable=False,
-                column_spec_display_name='column', type_code='type_code2')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_column_spec.assert_called_with({
-            'name': 'column',
-            'data_type': {
-                'type_code': 'type_code2',
-                'nullable': False,
-            }
-        })
-
-    def test_set_target_column_table_not_found(self):
-        client = self.tables_client({
-            'list_table_specs.side_effect': exceptions.NotFound('err'),
-        }, {})
-        try:
-            client.set_target_column(dataset_name='name',
-                    column_spec_display_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_not_called()
-        client.client.update_dataset.assert_not_called()
-
-    def test_set_target_column_not_found(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        column_spec_mock.configure_mock(name='column/1', display_name='column')
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        try:
-            client.set_target_column(dataset_name='name',
-                    column_spec_display_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_dataset.assert_not_called()
-
-    def test_set_target_column(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        column_spec_mock.configure_mock(name='column/1', display_name='column')
-        dataset_mock = mock.Mock()
-        tables_dataset_metadata_mock = mock.Mock()
-        tables_dataset_metadata_mock.configure_mock(target_column_spec_id='2',
-            weight_column_spec_id='2',
-            ml_use_column_spec_id='3')
-        dataset_mock.configure_mock(name='dataset',
-            tables_dataset_metadata=tables_dataset_metadata_mock)
-        client = self.tables_client({
-            'get_dataset.return_value': dataset_mock,
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.set_target_column(dataset_name='name',
-                column_spec_display_name='column')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_dataset.assert_called_with({
-            'name': 'dataset',
-            'tables_dataset_metadata': {
-                'target_column_spec_id': '1',
-                'weight_column_spec_id': '2',
-                'ml_use_column_spec_id': '3',
-            }
-        })
-
-    def test_set_weight_column_table_not_found(self):
-        client = self.tables_client({
-            'list_table_specs.side_effect': exceptions.NotFound('err'),
-        }, {})
-        try:
-            client.set_weight_column(dataset_name='name',
-                    column_spec_display_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_not_called()
-        client.client.update_dataset.assert_not_called()
-
-    def test_set_weight_column_not_found(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        column_spec_mock.configure_mock(name='column/1', display_name='column')
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        try:
-            client.set_weight_column(dataset_name='name',
-                    column_spec_display_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_dataset.assert_not_called()
-
-    def test_set_weight_column(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        column_spec_mock.configure_mock(name='column/2', display_name='column')
-        dataset_mock = mock.Mock()
-        tables_dataset_metadata_mock = mock.Mock()
-        tables_dataset_metadata_mock.configure_mock(target_column_spec_id='1',
-            weight_column_spec_id='1',
-            ml_use_column_spec_id='3')
-        dataset_mock.configure_mock(name='dataset',
-            tables_dataset_metadata=tables_dataset_metadata_mock)
-        client = self.tables_client({
-            'get_dataset.return_value': dataset_mock,
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.set_weight_column(dataset_name='name',
-                column_spec_display_name='column')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_dataset.assert_called_with({
-            'name': 'dataset',
-            'tables_dataset_metadata': {
-                'target_column_spec_id': '1',
-                'weight_column_spec_id': '2',
-                'ml_use_column_spec_id': '3',
-            }
-        })
-
-    def test_set_test_train_column_table_not_found(self):
-        client = self.tables_client({
-            'list_table_specs.side_effect': exceptions.NotFound('err'),
-        }, {})
-        try:
-            client.set_test_train_column(dataset_name='name',
-                    column_spec_display_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_not_called()
-        client.client.update_dataset.assert_not_called()
-
-    def test_set_test_train_column_not_found(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        column_spec_mock.configure_mock(name='column/1', display_name='column')
-        client = self.tables_client({
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        try:
-            client.set_test_train_column(dataset_name='name',
-                    column_spec_display_name='column2')
-        except exceptions.NotFound:
-            pass
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_dataset.assert_not_called()
-
-    def test_set_test_train_column(self):
-        table_spec_mock = mock.Mock()
-        # name is reserved in use of __init__, needs to be passed here
-        table_spec_mock.configure_mock(name='table')
-        column_spec_mock = mock.Mock()
-        column_spec_mock.configure_mock(name='column/3', display_name='column')
-        dataset_mock = mock.Mock()
-        tables_dataset_metadata_mock = mock.Mock()
-        tables_dataset_metadata_mock.configure_mock(target_column_spec_id='1',
-            weight_column_spec_id='2',
-            ml_use_column_spec_id='2')
-        dataset_mock.configure_mock(name='dataset',
-            tables_dataset_metadata=tables_dataset_metadata_mock)
-        client = self.tables_client({
-            'get_dataset.return_value': dataset_mock,
-            'list_table_specs.return_value': [table_spec_mock],
-            'list_column_specs.return_value': [column_spec_mock],
-        }, {})
-        client.set_test_train_column(dataset_name='name',
-                column_spec_display_name='column')
-        client.client.list_table_specs.assert_called_with('name')
-        client.client.list_column_specs.assert_called_with('table')
-        client.client.update_dataset.assert_called_with({
-            'name': 'dataset',
-            'tables_dataset_metadata': {
-                'target_column_spec_id': '1',
-                'weight_column_spec_id': '2',
-                'ml_use_column_spec_id': '3',
-            }
-        })
-
-    def test_list_models_empty(self):
-        client = self.tables_client({
-            'list_models.return_value': [],
-            'location_path.return_value': LOCATION_PATH,
-        }, {})
-        ds = client.list_models()
-        client.client.location_path.assert_called_with(PROJECT, REGION)
-        client.client.list_models.assert_called_with(LOCATION_PATH)
-        assert ds == []
-
-    def test_list_models_not_empty(self):
-        models = ['some_model']
-        client = self.tables_client({
-            'list_models.return_value': models,
-            'location_path.return_value': LOCATION_PATH,
-        }, {})
-        ds = client.list_models()
-        client.client.location_path.assert_called_with(PROJECT, REGION)
-        client.client.list_models.assert_called_with(LOCATION_PATH)
-        assert len(ds) == 1
-        assert ds[0] == 'some_model'
-
-    def test_get_model_name(self):
-        model_actual = 'model'
-        client = self.tables_client({
-            'get_model.return_value': model_actual
-            }, {})
-        model = client.get_model(model_name='my_model')
-        client.client.get_model.assert_called_with('my_model')
-        assert model == model_actual
-
-    def test_get_no_model(self):
-        client = self.tables_client({
-            'get_model.side_effect': exceptions.NotFound('err')
-        }, {})
-        try:
-            client.get_model(model_name='my_model')
-        except exceptions.NotFound:
-            pass
-        client.client.get_model.assert_called_with('my_model')
-
-    def test_get_model_from_empty_list(self):
-        client = self.tables_client({'list_models.return_value': []}, {})
-        try:
-            client.get_model(model_display_name='my_model')
-        except exceptions.NotFound:
-            pass
-
-    def test_get_model_from_list_not_found(self):
-        client = self.tables_client({
-            'list_models.return_value': [mock.Mock(display_name='not_it')]
-        }, {})
-        try:
-            client.get_model(model_display_name='my_model')
-        except exceptions.NotFound:
-            pass
-
-    def test_get_model_from_list(self):
-        client = self.tables_client({
-            'list_models.return_value': [
-                mock.Mock(display_name='not_it'),
-                mock.Mock(display_name='my_model'),
-            ]
-        }, {})
-        model = client.get_model(model_display_name='my_model')
-        assert model.display_name == 'my_model'
-
-    def test_delete_model(self):
-        model = mock.Mock()
-        model.configure_mock(name='name')
-        client = self.tables_client({
-            'delete_model.return_value': None,
-        }, {})
-        client.delete_model(model=model)
-        client.client.delete_model.assert_called_with('name')
-
-    def test_delete_model_not_found(self):
-        client = self.tables_client({
-            'list_models.return_value': [],
-        }, {})
-        client.delete_model(model_display_name='not_found')
-        client.client.delete_model.assert_not_called()
-
-    def test_delete_model_name(self):
-        client = self.tables_client({
-            'delete_model.return_value': None,
-        }, {})
-        client.delete_model(model_name='name')
-        client.client.delete_model.assert_called_with('name')
